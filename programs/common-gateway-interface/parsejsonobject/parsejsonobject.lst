     1                                  ; Name:        parsejsonobject
     2                                  ; Build:       see makefile
     3                                  ; Description: reply data in the form of a JSON object.  After building this application, you need
     4                                  ;              to upload this to your webservers cgi root folder.
     5                                  ; Remark:      For those who like to observe the network traffic, you can use:
     6                                  ;              sudo tcpdump -i lo -s0 -w capture.pcap to capture the network traffic in a file
     7                                  ;              which you can open with wireshark.
     8                                   
     9                                  bits 64
    10                                  
   327                                  [list -]
   328                                  
   329                                  section .bss
   330                                  
   331 00000000 <res 00000008>               oldbrkaddr:         resq 1
   332 00000008 <res 00000001>               charbuffer:         resb 1
   333 00000009 <res 00000008>               content:            resq 1   ; memory to store content length in
   334                                      
   335                                  section .data
   336                                  
   337 00000000 524551554553545F4D-          requestmethod:      db   "REQUEST_METHOD=POST"
   338 00000009 4554484F443D504F53-
   339 00000012 54                 
   340                                       .length:            equ  $-requestmethod
   341 00000013 434F4E54454E545F4C-          contentlength:      db   "CONTENT_LENGTH="
   342 0000001C 454E4754483D       
   343                                       .length:            equ  $-contentlength
   344                                  
   345                                  top:
   346 00000022 436F6E74656E742D74-               db   'Content-type: text/html', 0x0A, 0x0A,'{"'
   347 0000002B 7970653A2074657874-
   348 00000034 2F68746D6C0A0A7B22 
   349                                  .length:  equ  $-top
   350                                  
   351                                  middle:
   352 0000003D 223A22                            db   '":"'
   353                                  .length:  equ  $-middle    
   354                                  
   355                                  separator:
   356 00000040 222C22                            db   '","'
   357                                  .length:  equ  $-separator
   358                                  
   359                                  bottom:
   360 00000043 227D                              db   '"}'
   361                                  .length:  equ  $-bottom
   362                                  
   363                                  section .text
   364                                       global _start
   365                                  
   366                                  _start:
   367                                  
   368                                       ; first check if the form was posted
   369                                       ; adjust stack to environment parameters
   370 00000000 58                           pop       rax
   371 00000001 58                           pop       rax
   372 00000002 58                           pop       rax
   373 00000003 4889E5                       mov       rbp, rsp                 ; save begin of list in rbp
   374                                       ; let's loop through the webserver variables, searching for REQUEST_METHOD=POST
   375 00000006 FC                           cld
   376                                  .getrequestmethod:
   377 00000007 5E                           pop       rsi
   378 00000008 4809F6                       or        rsi, rsi                ; done yet?
   379 0000000B 0F846B010000                 jz        .exit                   ; we didn't find the REQUEST_METHOD=POST string   
   380                                       ; RDI contains a pointer to CONTENT_LENGTH=POST the variable we are searching for
   381                                       ; look for the required variable name amongst them
   382 00000011 B913000000                   mov       rcx, requestmethod.length
   383 00000016 48BF-                        mov       rdi, requestmethod
   384 00000018 [0000000000000000] 
   385 00000020 F3A6                         rep       cmpsb                   ; compare RCX bytes
   386 00000022 75E3                         jne       .getrequestmethod       ; no match get the next variable, if any
   387                                  
   388                                       ; we got a match, now read the CONTENT_LENGTH
   389                                       ; restore top of (list-1)
   390 00000024 4889EC                       mov       rsp, rbp
   391 00000027 FC                           cld                                 ; just in case
   392                                  .getcontentlength:
   393 00000028 5E                           pop       rsi
   394 00000029 4809F6                       or        rsi, rsi                ; done yet
   395 0000002C 0F844A010000                 jz        .exit                   ; this shouldn't occur
   396                                       ; RDI contains a pointer to CONTENT_LENGTH= the variable we are searching for
   397 00000032 B90F000000                   mov       rcx, contentlength.length
   398 00000037 48BF-                        mov       rdi, contentlength
   399 00000039 [1300000000000000] 
   400 00000041 F3A6                         rep       cmpsb                   ; compare RCX bytes
   401 00000043 75E3                         jne       .getcontentlength       ; no match get the next variable, if any
   402                                  
   403                                       ; we got the CONTENT_LENGTH=, RSI points to the first character of the ASCII digit of the length
   404                                       ; initialise rcx
   405 00000045 4831C9                       xor       rcx, rcx
   406                                  .nextparamstringchar:
   407 00000048 4831C0                       xor       rax, rax
   408 0000004B AC                           lodsb                               ; get digit
   409 0000004C 20C0                         and       al, al                   ; if 0 then no digits
   410 0000004E 7413                         je        .endofparamstring
   411                                  
   412 00000050 4831D2                       xor       rdx, rdx
   413 00000053 BB0A000000                   mov       rbx, 10
   414 00000058 480FAFCB                     imul      rcx, rbx
   415 0000005C 240F                         and       al, 0x0F
   416 0000005E 4801C1                       add       rcx, rax                ; previous digit x 10 + current digit    
   417 00000061 EBE5                         jmp       .nextparamstringchar
   418                                  .endofparamstring:   
   419                                       ; RCX contains the content_length in hexadecimal
   420                                       ; reserve space on, the heap to store the parameters from STDIN
   421 00000063 48890C25[09000000]           mov       QWORD[content], rcx
   422 0000006B BF00000000                   mov       rdi, 0
   423 00000070 B80C000000                   mov       rax, SYS_BRK
   424 00000075 0F05                         syscall
   425 00000077 48890425[00000000]           mov         QWORD[oldbrkaddr], rax  ; save the address to de-allocate memory
   426                                  
   427                                       ; reserve memory for the parameters
   428 0000007F 48030425[09000000]           add       rax, QWORD[content]            ; add contentlength to the program break
   429 00000087 4889C7                       mov       rdi, rax
   430 0000008A B80C000000                   mov       rax, SYS_BRK
   431 0000008F 0F05                         syscall
   432 00000091 4883F800                     cmp       rax, 0
   433 00000095 0F84E1000000                 je        .exit                   ; if RAX = 0 then no memory is available, now we exit
   434                                  
   435                                       ; read the params in our created buffer
   436 0000009B 488B3425[00000000]           mov       rsi, QWORD[oldbrkaddr]
   437 000000A3 488B1425[09000000]           mov       rdx, QWORD[content]               ; length of the parameterstring
   438 000000AB BF00000000                   mov       rdi, STDIN
   439 000000B0 B800000000                   mov       rax, SYS_READ
   440 000000B5 0F05                         syscall
   441                                  
   442                                       ; start the output of the data as a JSON object
   443 000000B7 BF01000000                   mov       rdi, STDOUT
   444 000000BC 48BE-                        mov       rsi, top
   445 000000BE [2200000000000000] 
   446 000000C6 BA1B000000                   mov       rdx, top.length
   447 000000CB B801000000                   mov       rax, SYS_WRITE
   448 000000D0 0F05                         syscall
   449                                  
   450                                       ; parse the data to a JSON object
   451                                       ; loop through the data until '='
   452 000000D2 488B3425[00000000]           mov         rsi, QWORD[oldbrkaddr]
   453 000000DA FC                           cld
   454                                  .repeat:    
   455 000000DB AC                           lodsb
   456 000000DC 20C0                         and       al, al
   457 000000DE 7472                         jz        .endloop
   458 000000E0 3C3D                         cmp       al,"="
   459 000000E2 7430                         je        .printmiddle
   460 000000E4 3C26                         cmp       al,"&"
   461 000000E6 744B                         je        .printseparator
   462 000000E8 3C2B                         cmp       al,"+"
   463 000000EA 7502                         jne       .printchar
   464                                       ; + will be replaced by space
   465 000000EC B020                         mov       al, " "
   466                                  .printchar:    
   467 000000EE 56                           push      rsi                             ; rsi on stack    
   468                                       ; print the character
   469 000000EF 880425[08000000]             mov       BYTE[charbuffer], al
   470 000000F6 48BE-                        mov       rsi, charbuffer
   471 000000F8 [0800000000000000] 
   472 00000100 BA01000000                   mov       rdx, 1
   473 00000105 BF01000000                   mov       rdi, STDOUT
   474 0000010A B801000000                   mov       rax, SYS_WRITE
   475 0000010F 0F05                         syscall
   476 00000111 5E                           pop       rsi
   477 00000112 EBC7                         jmp       .repeat
   478                                  .printmiddle:
   479 00000114 56                           push      rsi
   480 00000115 48BE-                        mov       rsi, middle
   481 00000117 [3D00000000000000] 
   482 0000011F BA03000000                   mov       rdx, middle.length
   483 00000124 BF01000000                   mov       rdi, STDOUT
   484 00000129 B801000000                   mov       rax, SYS_WRITE
   485 0000012E 0F05                         syscall
   486 00000130 5E                           pop       rsi
   487 00000131 EBA8                         jmp       .repeat
   488                                  .printseparator:
   489 00000133 56                           push      rsi
   490 00000134 48BE-                        mov       rsi, separator
   491 00000136 [4000000000000000] 
   492 0000013E BA03000000                   mov       rdx, separator.length
   493 00000143 BF01000000                   mov       rdi, STDOUT
   494 00000148 B801000000                   mov       rax, SYS_WRITE
   495 0000014D 0F05                         syscall
   496 0000014F 5E                           pop       rsi
   497 00000150 EB89                         jmp       .repeat
   498                                  .endloop:       
   499 00000152 BF01000000                   mov       rdi, STDOUT
   500 00000157 48BE-                        mov       rsi, bottom
   501 00000159 [4300000000000000] 
   502 00000161 BA02000000                   mov       rdx, bottom.length
   503 00000166 B801000000                   mov       rax, SYS_WRITE
   504 0000016B 0F05                         syscall
   505                                  
   506                                       ; release the reserved memory
   507                                       ; free the allocated memory
   508 0000016D 488B3C25[00000000]           mov       rdi, QWORD[oldbrkaddr]
   509 00000175 B80C000000                   mov       rax, SYS_BRK
   510 0000017A 0F05                         syscall
   511                                  
   512                                       ; and exit the program
   513                                  .exit:
   514 0000017C 4831FF                       xor       rdi, rdi
   515 0000017F B83C000000                   mov       rax, SYS_EXIT
   516 00000184 0F05                         syscall    
